# जावास्क्रिप्ट में एल्गोरिदम और डेटा संरचनाएं

![सीआई](https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg)
[![codecov](https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg)](https://codecov.io/gh/trekhleb/javascript-algorithms)

क्वेस्टा रिपोजिटरी में सबसे लोकप्रिय एल्गोरिदम और डेटा संरचना के जावास्क्रिप्ट में उदाहरण हैं

आपको एल्गोरिथम और संरचना पहले से ही मिल जाती है और इसका README संबंधित स्पाइवेयर से अलग होता है और आगे की गहराई के लिए इसका लिंक (जिसमें इसका YouTube भी शामिल है)।

_लेगिलो अन्य भाषाओं में:_
[_简体中文_](README.zh-CN.md),
[_繁體中文_](README.zh-TW.md),
[_한국어_](README.ko-KR.md),
[_日本語_](README.ja-JP.md),
[_Polski_](README.pl-PL.md),
[_Français_](README.fr-FR.md),
[_Español_](README.es-ES.md),
[_Português_](README.pt-BR.md),
[_Русский_](README.ru-RU.md),
[_Türk_](README.tr-TR.md),
[_Bahasa Indonesia_](README.id-ID.md),
[_Українська_](README.uk-UA.md),
[_Arabic_](README.ar-AR.md),
[_Tiếng Việt_](README.vi-VN.md),
[_Deutsch_](README.de-DE.md),
[_Hindi_](README.Hi-Hi.md)


*☝ कृपया ध्यान दें कि इस परियोजना का उपयोग केवल सीखने और शोध के लिए किया जाना है और व्यावसायिक उद्देश्यों के लिए उपयोग करने का इरादा नहीं है।*

## पिछला ढांचा

डेटा संरचना कंप्यूटर में डेटा को व्यवस्थित और याद रखने का एक विशेष तरीका है जो आपको इसे कुशलतापूर्वक एक्सेस और संशोधित करने की अनुमति देता है। अधिक सटीक रूप से, एक तिथि संरचना दिनांक से संबंध है, निबंध और कार्यों या संचालन के बीच संबंध जो तिथि पर लागू हो सकते हैं।

`पी` - शुरुआती, `ए` - उन्नत

* `पी` [संबद्ध सूची] (src/डेटा-संरचना/लिंक्ड-सूची);
* `पी` [डोपिया कॉनटेनेटेड लिस्ट] (src/डेटा-स्ट्रक्चर/डबल-लिंक्ड-लिस्ट);
* `पी` [कोडा] (src/डेटा-संरचना/कतार)
* `पी` [स्टैक] (src/डेटा-स्ट्रक्चर/स्टैक)
* `पी` [हैश टेबल] (src/डेटा-स्ट्रक्चर/हैश-टेबल);
* `पी` [हीप] (src/डेटा-स्ट्रक्चर/हीप) - अधिकतम और न्यूनतम हीप संस्करण
* `पी` [प्राथमिकता कोड](src/डेटा-संरचना/प्राथमिकता-कतार)
* `ए` [ट्राई](src/data-structs/trie)
* `ए` [अल्बेरो] (src/डेटा-संरचना/पेड़);
* `ए` [हालिया बाइनरी अल्बेरो](src/data-structs/tree/binary-search-tree)
* `ए` [अल्बेरो एवीएल](src/data-structs/tree/avl-tree);
* `ए` [आरबी अलबेरो](src/data-structs/tree/red-black-tree);
* `ए` [अल्बेरो सेगमेंटेशन] (src/डेटा-स्ट्रक्चर/ट्री/सेगमेंट-ट्री) - क्वेरी में दिखाए गए न्यूनतम/अधिकतम/योग के साथ
* `ए` [फेनविक अल्बेरो] (src/डेटा-स्ट्रक्चर/पेड़/फेनविक-पेड़) (अल्बेरो बाइनरी इंडिसीजेटो)
* `ए` [ग्राफ] (src/डेटा-संरचना/ग्राफ) (दिशात्मक और यूनिडायरेक्शनल);
* `ए` [डिसजॉइंटसेट] (src/डेटा-स्ट्रक्चर/डिसजॉइंट-सेट)
* `ए` [ब्लूम फ़िल्टर] (src/डेटा-स्ट्रक्चर/ब्लूम-फ़िल्टर);

## एल्गोरिदम

एक एल्गोरिथ्म समस्याओं के एक वर्ग को हल करने के लिए एक अनूठा विनिर्देश है। है
नियमों का एक सेट जो संचालन के अनुक्रम को सटीक रूप से परिभाषित करता है।

`पी` - शुरुआती, `ए` - उन्नत

### विषय एल्गोरिदम

* **गणित**
  * `पी` [बिट हेरफेर] (src / एल्गोरिदम / गणित / बिट्स) - सेट / प्राप्त / अपडेट / स्पष्ट बिट्स, दो से गुणा / विभाजित करें, नकारात्मक संख्याओं को संभालें आदि।
  * `पी` [फैक्टोरियल] (src / एल्गोरिदम / गणित / फैक्टोरियल)
  * `पी` [फाइबोनैचि संख्या] (src / एल्गोरिदम / गणित / फाइबोनैचि) - क्लासिक और बंद रूप
  * `पी` [प्राथमिकता परीक्षण] (src/एल्गोरिदम/गणित/प्राथमिकता परीक्षण) (भाजक विधि)
  * `P` [यूक्लिड का एल्गोरिथ्म] (src / एल्गोरिदम / गणित / यूक्लिडियन-एल्गोरिदम) - सबसे बड़ा सामान्य भाजक (GCD) खोजें
  * `पी` [न्यूनतम सामान्य एकाधिक] (src / एल्गोरिदम / गणित / कम से कम-सामान्य-एकाधिक) (एमसीएम)
  * `P` [इरेटोस्थनीज की छलनी] (src / एल्गोरिदम / गणित / चलनी-की-इरेटोस्थनीज) - निर्दिष्ट सीमा तक अभाज्य संख्याएँ ढूँढता है
  * `पी` [दो की शक्ति] (src / एल्गोरिदम / गणित / दो की शक्ति है) - जांचें कि क्या संख्या दो की शक्ति है
  * `पी` [पास्कल का त्रिकोण] (src / एल्गोरिदम / गणित / पास्कल-त्रिकोण)
  * `पी` [कॉम्प्लेक्स नंबर] (src / एल्गोरिदम / गणित / कॉम्प्लेक्स-नंबर) - कॉम्प्लेक्स नंबर और ऑपरेशन
  * `पी` [रेडियन और डिग्री] (src / एल्गोरिदम / गणित / रेडियन) - रेडियन से डिग्री में रूपांतरण और इसके विपरीत
  * `पी` [एक संख्या की शक्ति] (src / एल्गोरिदम / गणित / तेज-शक्ति)
  * `ए` [एक पूर्णांक का विभाजन] (src / एल्गोरिदम / गणित / पूर्णांक-विभाजन)
  * `ए` [वर्गमूल] (src/एल्गोरिदम/गणित/वर्गमूल) - न्यूटन की विधि
  * `ए` [लियू हुई π एल्गोरिदम] (src / एल्गोरिदम / गणित / लियू-हुई) - बहुभुज का उपयोग करके की गणना करें
  * `ए` [असतत फूरियर ट्रांसफॉर्म] (src / एल्गोरिदम / गणित / फूरियर-ट्रांसफॉर्म) - अपने घटक आवृत्तियों में एक समय समारोह (एक संकेत) को विघटित करें
* **समूह**
  * `पी` [कार्टेशियन उत्पाद] (src / एल्गोरिदम / सेट / कार्टेशियन-उत्पाद) - सेट के कई गुणा
  * `पी` [फिशर - येट्स शफल] (src / एल्गोरिदम / सेट / फिशर-येट्स) - एक परिमित अनुक्रम का यादृच्छिक क्रमपरिवर्तन
  * `ए` [पावर सेट] (src / एल्गोरिदम / सेट / पावर-सेट) - एक सेट के सभी सबसेट (बिटवाइज और बैकट्रैकिंग समाधान)
  * `ए` [क्रमपरिवर्तन] (src / एल्गोरिदम / सेट / क्रमपरिवर्तन) (दोहराव के साथ और बिना)
  * `ए` [संयोजन] (src / एल्गोरिदम / सेट / संयोजन) (दोहराव के साथ और बिना)
  * `ए` [अधिकतम सामान्य सॉटोसेक्वेंस] (src / एल्गोरिदम / सेट / सबसे लंबा-आम-अनुक्रम) (LCS)
  * `ए` [अधिकतम आरोही सॉटोसेक्वेंस] (src / एल्गोरिदम / सेट / सबसे लंबी-बढ़ती-अनुक्रम)
  * `ए` [न्यूनतम डिफ्यूज़ सॉटोसेक्वेंस] (src / एल्गोरिदम / सेट / सबसे छोटा-सामान्य-सुपरसीक्वेंस) (SCS)
  * `ए` [नैपसेक बैकपैक समस्या] (src/एल्गोरिदम/सेट/नैप्सैक-समस्या) -" 0/1 "और" अप्रतिबंधित "
  * `ए` [अधिकतम सबअरे] (src / एल्गोरिदम / सेट / अधिकतम-सबरे) - "ब्रूट फोर्स" और "डायनेमिक प्रोग्रामिंग" कडाने संस्करण
  * `ए` [संयोजन का योग] (src / एल्गोरिदम / सेट / संयोजन-योग) - योग के सभी संयोजनों की खोज करें
* **डोरी**
  * `पी` [हैमिंग दूरी] (src / एल्गोरिदम / स्ट्रिंग / हैमिंग-दूरी) - पदों की संख्या जहां वर्ण भिन्न हैं
  * `ए` [लेवेनशेटिन दूरी] (src / एल्गोरिदम / स्ट्रिंग / लेवेनशेटिन-दूरी) - दो तारों को बराबर बनाने के लिए न्यूनतम परिवर्तन
  * `ए` [नुथ-मॉरिस-प्रैट एल्गोरिथम] (src / एल्गोरिदम / स्ट्रिंग / नुथ-मॉरिस-प्रैट) (KMP) - सबस्ट्रिंग में खोजें (पैटर्न मिलान)
  * `ए` [एल्गोरिदम जेड] (src / एल्गोरिदम / स्ट्रिंग / z-एल्गोरिदम) - सबस्ट्रिंग में खोजें (पैटर्न मिलान)
  * `ए` [राबिन कार्प एल्गोरिथम] (src / एल्गोरिदम / स्ट्रिंग / राबिन-कार्प) - सबस्ट्रिंग में खोजें
  * `ए` [सबसे लंबा सामान्य सबस्ट्रिंग] (src / एल्गोरिदम / स्ट्रिंग / सबसे लंबा-सामान्य-सबस्ट्रिंग)
  * `ए` [रेगुलर एक्सप्रेशन] (src / एल्गोरिदम / स्ट्रिंग / रेगुलर-एक्सप्रेशन-मिलान)
* **खोज**
  * `पी` [रिसेर्का सीक्वेंज़ियाल] (src/एल्गोरिदम/खोज/रैखिक-खोज)
  * `पी` [रिसेर्का ए साल्टी](src/एल्गोरिदम/सर्च/जंप-सर्च) (ओ रिसेर्का ए ब्लोची) - प्रति ला रिसेर्का इन एरे ऑर्डिनेटी
  * `पी` [रिसेर्का बिनारी](src/एल्गोरिदम/खोज/बाइनरी-सर्च) - सरणी क्रम में प्रति ला रिसेर्का
  * `पी` [रिसेर्का इंटरपोलाटा](src/एल्गोरिदम/खोज/इंटरपोलेशन-सर्च) - प्रति ला रिसेर्का इन अन एरे ऑर्डिनेटो यूनिफॉर्मेमेंट डिस्टिब्यूटो
**क्रमबद्ध करना**
  * `पी` [बबल सॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/बबल-सॉर्ट)
  * `पी` [चयन सॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/चयन-सॉर्ट)
  * `पी` [सम्मिलन सॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/सम्मिलन-सॉर्ट)
  * `पी` [हीप सॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/हीप-सॉर्ट)
  * `पी` [मर्ज सॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/मर्ज-सॉर्ट)
  * `पी` [क्विकसॉर्ट](src/एल्गोरिदम/सॉर्टिंग/क्विक-सॉर्ट) - कोन ई सेंजा एलोकाज़ियोन डि अल्टीरियर मेमोरिया
  * `पी` [शैलसॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/शेल-सॉर्ट)
  * `पी` [काउंटिंग सॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/काउंटिंग-सॉर्ट)
  * `पी` [रेडिक्स सॉर्ट] (src/एल्गोरिदम/सॉर्टिंग/रेडिक्स-सॉर्ट)
**सम्मिलित सूची **
   * `पी` [ट्रैवर्सल लिंक्ड लिस्ट] (src / एल्गोरिदम / लिंक्ड-लिस्ट / ट्रैवर्सल)
   * `पी` [विपरीत अर्थों में ट्रैवर्सल लिंक्ड लिस्ट] (src / एल्गोरिदम / लिंक्ड-लिस्ट / रिवर्स-ट्रैवर्सल)
* **पेड़**
   * `पी` [पेड़ों पर गहरी खोज] (src / एल्गोरिदम / पेड़ / गहराई-पहली खोज) (डीएफएस)
   * `पी` [पेड़ों पर चौड़ाई खोज] (src / एल्गोरिदम / पेड़ / चौड़ाई-पहली खोज) (बीएफएस)
* ** रेखांकन **
  * `पी` [ग्राफ पर गहराई में खोजें] (src / एल्गोरिदम / ग्राफ / गहराई-पहली खोज) (डीएफएस)
  * `पी` [ग्राफ पर चौड़ाई-पहली खोज] (src / एल्गोरिदम / ग्राफ / चौड़ाई-प्रथम-खोज) (बीएफएस)
  * `पी` [क्रुस्कल का एल्गोरिदम] (src / एल्गोरिदम / ग्राफ / क्रुस्कल) - यूनिडायरेक्शनल वेटेड ग्राफ के लिए न्यूनतम दूरी ट्री (एमएसटी) खोज
  * `ए` [डिजस्ट्रा का एल्गोरिथ्म] (src / एल्गोरिदम / ग्राफ / डिजस्ट्रा) - एक ही शीर्ष से ग्राफ के सभी शीर्षों तक पहुंचने के लिए सबसे छोटा रास्ता खोजें
  * `ए` [बेलमैन-फोर्ड एल्गोरिथम] (src / एल्गोरिदम / ग्राफ / बेलमैन-फोर्ड) - एक ही शीर्ष से ग्राफ के सभी शीर्षों तक पहुंचने के लिए सबसे छोटा रास्ता खोजें
  * `ए` [फ्लोयड-वॉर्शल एल्गोरिथम] (src / एल्गोरिदम / ग्राफ / फ्लोयड-वारशॉल) - सभी जोड़ियों के बीच सबसे छोटे रास्तों की खोज करें
  * `ए` [साइकिल डिटेक्शन] (src / एल्गोरिदम / ग्राफ / डिटेक्ट-साइकल) - प्रत्यक्ष और गैर-प्रत्यक्ष ग्राफ़ के लिए (DFS और डिसजॉइंट सेट विभाजन पर आधारित)
  * `ए` [प्राइम का एल्गोरिदम] (src / एल्गोरिदम / ग्राफ / प्राइम) - भारित यूनिडायरेक्शनल ग्राफ के लिए न्यूनतम स्पैनिंग ट्री (एमएसटी) खोज
  * `ए` [टोपोलॉजिकल सॉर्टिंग] (src / एल्गोरिदम / ग्राफ / टोपोलॉजिकल-सॉर्टिंग) - डीएफएस विधि
  * `ए` [आर्टिक्यूलेशन पॉइंट्स] (src / एल्गोरिदम / ग्राफ / आर्टिक्यूलेशन-पॉइंट्स) - टार्जन का एल्गोरिथम (DFS पर आधारित)
  * `ए` [पुल] (src / एल्गोरिदम / ग्राफ / पुल) - DFS पर आधारित
  * `ए` [यूलेरियन पथ और यूलेरियन सर्किट] (src / एल्गोरिदम / ग्राफ / यूलरियन-पथ) - फ्लेरी का एल्गोरिदम - प्रत्येक किनारे पर ठीक एक बार जाएँ
  * `ए` [हैमिल्टनियन चक्र] (src / एल्गोरिदम / ग्राफ / हैमिल्टनियन-चक्र) - प्रत्येक शीर्ष पर केवल एक बार जाएँ
  * `ए` [मजबूत रूप से जुड़े घटक] (src / एल्गोरिदम / ग्राफ / दृढ़ता से जुड़े-घटक) - कोसरजू एल्गोरिदम
  * `ए` [ट्रैवलिंग सेल्समैन प्रॉब्लम] (src / एल्गोरिदम / ग्राफ / ट्रैवलिंग-सेल्समैन) - सबसे छोटा मार्ग जो प्रत्येक शहर का दौरा करता है और शुरुआती शहर में लौटता है
* **कूटलेखन **
* `पी` [बहुपद हैश] (src / एल्गोरिदम / क्रिप्टोग्राफी / बहुपद-हैश) - एक बहुपद-आधारित रोलिंग हैश फ़ंक्शन
* **अवर्गीकृत **
  * `पी` [हनोई का टॉवर] (स्रोत / एल्गोरिदम / अवर्गीकृत / हनोई-टॉवर)
  * `पी` [स्क्वायर मैट्रिक्स रोटेशन] (src / एल्गोरिदम / अवर्गीकृत / वर्ग-मैट्रिक्स-रोटेशन) - स्मृति में एल्गोरिथ्म
  * `पी` [जंप गेम] (src / एल्गोरिदम / अवर्गीकृत / जंप-गेम) - बैकट्रैकिंग, डायनेमिक प्रोग्रामिंग (टॉप-डाउन + बॉटम-अप) और लालची उदाहरण
  * `पी` [अद्वितीय पथ] (src / एल्गोरिदम / अवर्गीकृत / अद्वितीय-पथ) - बैकट्रैकिंग, गतिशील प्रोग्रामिंग और पास्कल के त्रिभुज का उदाहरण
  * `पी` [रेन टैरेस] (src / एल्गोरिदम / अवर्गीकृत / वर्षा-छतें) - फंसी हुई वर्षा जल समस्या (गतिशील प्रोग्रामिंग और पाशविक बल के साथ संस्करण)
  * `पी` [पुनरावर्ती सीढ़ी] (src / एल्गोरिदम / अवर्गीकृत / पुनरावर्ती-सीढ़ी) - शिखर तक पहुंचने के लिए मार्गों की संख्या की गणना करें (4 समाधान)
  * `ए` [आठ क्वींस पहेली] (src / एल्गोरिदम / अवर्गीकृत / n-रानी)
  * `ए` [घोड़े का पथ] (स्रोत / एल्गोरिदम / अवर्गीकृत / नाइट-टूर)
### एल्गोरिथम मॉडल

 एक एल्गोरिथ्म मॉडल एक सामान्य विधि या दृष्टिकोण है जो एल्गोरिदम के एक वर्ग के डिजाइन को रेखांकित करता है।
 यह एक एल्गोरिथम का और भी अधिक अमूर्तन है, जैसे कि एक एल्गोरिथम एक कंप्यूटर प्रोग्राम का एक अमूर्तन है।

**ब्रूट फोर्स ** - सभी संभावनाओं की जांच करें और सर्वश्रेष्ठ का चयन करें
  * `पी` [रैखिक खोज] (src / एल्गोरिदम / खोज / रैखिक-खोज)
  * `पी` [रेन टेरेस] (src / एल्गोरिदम / अवर्गीकृत / वर्षा-छतें) - फंसे हुए वर्षा जल की समस्या
  * `पी` [पुनरावर्ती सीढ़ी] (src / एल्गोरिदम / अवर्गीकृत / पुनरावर्ती-सीढ़ी) - शिखर तक पहुंचने के लिए मार्गों की संख्या गिनें
  * `ए` [अधिकतम सबअरे] (src / एल्गोरिदम / सेट / अधिकतम-सबअरे)
  * `ए` [ट्रैवलिंग सेल्समैन प्रॉब्लम] (src / एल्गोरिदम / ग्राफ / ट्रैवलिंग-सेल्समैन) - सबसे छोटा रास्ता जो प्रत्येक शहर का दौरा करता है और शुरुआती शहर में लौटता है
  * `ए` [असतत फूरियर ट्रांसफॉर्म] (src / एल्गोरिदम / गणित / फूरियर-ट्रांसफॉर्म) - घटक आवृत्तियों में समय के फ़ंक्शन (सिग्नल) को विघटित करें
**लालची ** - भविष्य के लिए कोई विचार किए बिना, एल्गोरिथ्म विकसित करते समय सबसे अच्छा विकल्प चुनें
  * `पी` [जंप गेम] (src / एल्गोरिदम / अवर्गीकृत / कूद-खेल)
  * `ए` [नैपसेक बैकपैक समस्या] (src / एल्गोरिदम / सेट / बस्ता-समस्या)
  * `ए` [डिजस्ट्रा का एल्गोरिथ्म] (src / एल्गोरिदम / ग्राफ / डिजस्ट्रा) - ग्राफ के सभी कोने के बीच सबसे छोटा रास्ता खोजें
  * `ए` [प्राइम का एल्गोरिदम] (src / एल्गोरिदम / ग्राफ / प्राइम) - भारित और यूनिडायरेक्शनल ग्राफ के लिए कम से कम फैले पेड़ की खोज करें
  * `ए` [क्रुस्कल का एल्गोरिथम] (src / एल्गोरिदम / ग्राफ / क्रुस्कल) - भारित अप्रत्यक्ष ग्राफ के लिए न्यूनतम स्पैनिंग ट्री (MST) खोजना
* **फूट डालो और जीतो ** - समस्या को छोटे भागों में विभाजित करें और प्रत्येक भाग को हल करें
  * `पी` [बाइनरी सर्च] (src / एल्गोरिदम / सर्च / बाइनरी-सर्च)
  * `पी` [हनोई का टॉवर] (स्रोत / एल्गोरिदम / अवर्गीकृत / हनोई-टॉवर)
  * `पी` [पास्कल का त्रिकोण] (src / एल्गोरिदम / गणित / पास्कल-त्रिकोण)
  * `P` [यूक्लिड का एल्गोरिथ्म] (src / एल्गोरिदम / गणित / यूक्लिडियन-एल्गोरिदम) - सबसे बड़े सामान्य भाजक (GCD) की गणना करें
  * `पी` [मर्ज सॉर्ट] (src / एल्गोरिदम / सॉर्टिंग / मर्ज-सॉर्ट)
  * `पी` [क्विकसॉर्ट] (src / एल्गोरिदम / सॉर्टिंग / क्विक-सॉर्ट)
  * `पी` [डीप सर्च के लिए ट्री] (src / एल्गोरिदम / ट्री / डेप्थ-फर्स्ट-सर्च) (DFS)
  * `पी` [गहराई खोज के लिए ग्राफ] (src / एल्गोरिदम / ग्राफ / गहराई-पहली खोज) (डीएफएस)
  * `पी` [जंप गेम] (src / एल्गोरिदम / अवर्गीकृत / कूद-खेल)
  * `पी` [पावर अप एल्गोरिथम] (src / एल्गोरिदम / गणित / तेज-शक्ति)
  * `ए` [क्रमपरिवर्तन] (src / एल्गोरिदम / सेट / क्रमपरिवर्तन) (दोहराव के साथ या बिना)
  * `ए` [संयोजन] (src / एल्गोरिदम / सेट / संयोजन) (दोहराव के साथ या बिना)
**डायनेमिक प्रोग्रामिंग ** - ऊपर पाए गए उप-समाधानों का उपयोग करके एक समाधान बनाएं
  * `पी` [फाइबोनैचि संख्या] (src / एल्गोरिदम / गणित / फाइबोनैचि)
  * `पी` [जंप गेम] (src / एल्गोरिदम / अवर्गीकृत / कूद-खेल)
  * `पी` [अद्वितीय पथ] (src / एल्गोरिदम / अवर्गीकृत / अद्वितीय-पथ)
  * `पी` [रेन टेरेस] (src / एल्गोरिदम / अवर्गीकृत / वर्षा-छतें) - फंसे हुए वर्षा जल की समस्या
  * `पी` [पुनरावर्ती सीढ़ी] (src / एल्गोरिदम / अवर्गीकृत / पुनरावर्ती-सीढ़ी) - शिखर तक पहुंचने के लिए मार्गों की संख्या गिनें
  * `ए` [लेवेनशेटिन दूरी] (src / एल्गोरिदम / स्ट्रिंग / लेवेनशेटिन-दूरी) - दो अनुक्रमों के बीच न्यूनतम भिन्नता
  * `ए` [सबसे लंबा लगातार उप-अनुक्रम] (src / एल्गोरिदम / सेट / सबसे लंबा-सामान्य-अनुक्रम) (LCS)
  * `ए` [सबसे लंबे समय तक लगातार सबस्ट्रिंग] (src / एल्गोरिदम / स्ट्रिंग / सबसे लंबी-सामान्य-सबस्ट्रिंग)
  * `ए` [सबसे लंबा आरोही क्रम] (src / एल्गोरिदम / सेट / सबसे लंबा-बढ़ता-अनुक्रम)
  * `ए` [सबसे छोटा और सबसे लगातार सुपरसीक्वेंस] (src / एल्गोरिदम / सेट / सबसे छोटा-सामान्य-सुपरसीक्वेंस)
  * `ए` [बैकपैक समस्या] (src / एल्गोरिदम / सेट / बस्ता-समस्या)
  * `ए` [एक पूर्णांक का विभाजन] (src / एल्गोरिदम / गणित / पूर्णांक-विभाजन)
  * `ए` [अधिकतम सबअरे] (src / एल्गोरिदम / सेट / अधिकतम-सबअरे)
  * `ए` [बेलमैन-फोर्ड एल्गोरिथम] (src / एल्गोरिदम / ग्राफ / बेलमैन-फोर्ड) - ग्राफ के सभी कोने के लिए सबसे छोटा रास्ता खोजें
  * `ए` [फ्लोयड-वॉर्शल एल्गोरिथम] (src / एल्गोरिदम / ग्राफ / फ्लोयड-वारशॉल) - सभी जोड़ियों के बीच सबसे छोटा रास्ता खोजें
  * `ए` [रेगुलर एक्सप्रेशन] (src / एल्गोरिदम / स्ट्रिंग / रेगुलर-एक्सप्रेशन-मिलान)

* **बैकट्रैकिंग ** - क्रूर बल की तरह, सभी संभावित समाधान उत्पन्न करने का प्रयास करें, लेकिन हर बार जब आप अगला समाधान परीक्षण उत्पन्न करते हैं तो यह सभी शर्तों को पूरा करता है और उसके बाद ही बाद के समाधान उत्पन्न करना जारी रखता है। अन्यथा, पीछे हटें, और समाधान खोजने के लिए एक अलग रास्ते पर जाएँ। आम तौर पर डीएफएस एल्गोरिथम का उपयोग किया जाता है।
  * `पी` [जंप गेम] (src / एल्गोरिदम / अवर्गीकृत / कूद-खेल)
  * `पी` [अद्वितीय पथ] (src / एल्गोरिदम / अवर्गीकृत / अद्वितीय-पथ)
  * `पी` [पावर सेट] (src / एल्गोरिदम / सेट / पावर-सेट) - एक सेट के सभी सबसेट
  * `ए` [हैमिल्टनियन चक्र] (src / एल्गोरिदम / ग्राफ / हैमिल्टनियन-चक्र) - केवल एक बार सभी शीर्षों पर जाएँ
  * `ए` [एन-क्वींस समस्या] (स्रोत / एल्गोरिदम / अवर्गीकृत / एन-क्वींस)
  * `ए` [नाइट्स टूर] (src / एल्गोरिदम / अवर्गीकृत / नाइट-टूर)
  * `ए` [एक योग का संयोजन] (src / एल्गोरिदम / सेट / संयोजन-योग) - सभी संयोजन खोजें जो एक योग बनाते हैं
* **शाखा और बाध्य ** - याद रखें कि बैकट्रैकिंग के दौरान प्रत्येक चरण पर पाया जाने वाला सबसे कम खर्चीला समाधान है
समस्या के समाधान की न्यूनतम लागत की निचली सीमा तक पाए जाने वाले कम से कम महंगे समाधान का उपयोग करने की लागत,
कम से कम महंगे समाधान की तुलना में अधिक लागत वाले आंशिक समाधानों को त्यागने के लिए।
अनुप्रस्थ बीएफएस आमतौर पर अनुप्रस्थ डीएफएस के संयोजन में प्रयोग किया जाता है।

## इस भंडार का उपयोग कैसे करें

**सभी निर्भरताएं स्थापित करें **
``
एनपीएम इंस्टॉल
``

**ईएसलिंट चलाएं **

आप इसका उपयोग कोड की गुणवत्ता जांचने के लिए कर सकते हैं।

``
एनपीएम रन लिंट
``

**सभी परीक्षण चलाएं **
``
एनपीएम परीक्षण
``

**नाम से एक परीक्षण करें **
``
एनपीएम परीक्षण - 'लिंक्डलिस्ट'
``

**खेल का मैदान **


* बिग ओ नोटेशन * का उपयोग निष्पादन समय या एआई के आधार पर एल्गोरिदम को वर्गीकृत करने के लिए किया जाता है
अंतरिक्ष की आवश्यकताएं जो इनपुट की वृद्धि के साथ बढ़ती हैं।
नीचे दिए गए ग्राफ़ में आप बिग ओ नोटेशन का उपयोग करके एल्गोरिदम के सबसे सामान्य विकास क्रम पा सकते हैं।

! [बिग ओ ग्राफ़] (./ एसेट / big-o-graph.png)

संदर्भ: [बिग ओ चीट शीट] (http://bigocheatsheet.com/)।

नीचे दी गई तालिका विभिन्न इनपुट मात्राओं की तुलना में सबसे अधिक उपयोग किए जाने वाले बिग ओ नोटेशन और उनके प्रदर्शन की सूची दिखाती है।

| बिग ओ नोटेशन | 10 तत्वों के साथ संगणना | 100 तत्वों के साथ संगणना | 1000 तत्वों के साथ संगणना |
| --------------- | ----------------------------- | ----------------------------- | ----------------------------- |
| **ओ (1) ** | 1 | 1 | 1 |
| ** हे (लॉग एन) ** | 3 | 6 | 9 |
| ** हे (एन) ** | 10 | 100 | 1000 |
| ** हे (एन लॉग एन) ** | 30 | 600 | 9000 |
| ** ओ (एन ^ 2) ** | 100 | 10000 | 1000000 |
| ** ओ (2 ^ एन) ** | 1024 | 1.26e + 29 | 1.07e + 301 |
| ** हे (एन!) ** | 3628800 | 9.3e + 157 | 4.02e + 2567 |
### डेटा संरचनाओं पर संचालन की जटिलता

| डेटा संरचना | पहुंच | खोजें | सम्मिलन | हटाना | टिप्पणियाँ |
| ----------------------- | : -------: | : -------: | : --------: | : -------: | : -------- |
| ** सरणी ** | 1 | एन | एन | एन | |
| ** बैटरी ** | एन | एन | 1 | 1 | |
| **पूंछ ** | एन | एन | 1 | 1 | |
| **लिंक्ड लिस्ट ** | एन | एन | 1 | एन | |
| ** हैश टेबल ** | - | एन | एन | एन | एक पूर्ण हैशिंग फ़ंक्शन के मामले में, लागत O (1) | . होगी
| ** बाइनरी सर्च ट्री ** | एन | एन | एन | एन | एक संतुलित वृक्ष के मामले में लागत O (log (n)) होगी |
| ** बी-ट्री ** | लॉग (एन) | लॉग (एन) | लॉग (एन) | लॉग (एन) | |
| ** लाल-काले पेड़ ** | लॉग (एन) | लॉग (एन) | लॉग (एन) | लॉग (एन) | |
| ** एवीएल ट्री ** | लॉग (एन) | लॉग (एन) | लॉग (एन) | लॉग (एन) | |
| ** ब्लूम फ़िल्टर ** | - | 1 | 1 | - | खोज के दौरान झूठी सकारात्मकता संभव है |

### ऐरे सॉर्टिंग एल्गोरिदम की जटिलता

| नाम | उत्तम | मीडिया | पेर्गिओर | मेमोरी | स्थिर | टिप्पणियाँ |
| --------------------- | : -------------: | : -----------------: | : -----------------: | : -------: | : -------: | : -------- |
| ** बबल सॉर्ट ** | एन | एन <sup> 2 </sup> | एन <sup> 2 </sup> | 1 | हाँ | |
| ** प्रविष्टि क्रम ** | एन | एन <sup> 2 </sup> | एन <sup> 2 </sup> | 1 | हाँ | |
| ** चयन प्रकार ** | एन <sup> 2 </sup> | एन <sup> 2 </sup> | एन <sup> 2 </sup> | 1 | नहीं | |
| ** हीप सॉर्ट ** | n & nbsp; लॉग (एन) | n & nbsp; लॉग (एन) | n & nbsp; लॉग (एन) | 1 | नहीं | |
| ** मर्ज सॉर्ट ** | n & nbsp; लॉग (एन) | n & nbsp; लॉग (एन) | n & nbsp; लॉग (एन) | एन | हाँ | |
| **त्वरित छँटाई**| n & nbsp; लॉग (एन) | n & nbsp; लॉग (एन) | एन <sup> 2 </sup> | लॉग (एन) | नहीं | क्विक्सोर्ट आमतौर पर ओ (लॉग (एन)) के ढेर के साथ स्मृति में चलता है |
| **शैल सॉर्ट ** | n & nbsp; लॉग (एन) | अनुक्रम में रिक्त स्थान पर निर्भर करता है | n & nbsp; (लॉग (एन)) <sup> 2 </sup> | 1 | नहीं | |
| ** काउंटिंग सॉर्ट ** | एन + आर | एन + आर | एन + आर | एन + आर | हाँ | r - सरणी में सबसे बड़ी संख्या |
| ** मूलांक सॉर्ट ** | एन * के | एन * के | एन * के | एन + के | हाँ | k - सबसे बड़ी कुंजी की लंबाई |

> ℹ️ [trekhleb.dev] पर जावास्क्रिप्ट और एल्गोरिदम के बारे में कुछ और [प्रोजेक्ट्स] (https://trekleb.dev/projects/) और [लेख] (https://trekhleb.dev/blog/) (https: / /ट्रेखलेब.देव)
